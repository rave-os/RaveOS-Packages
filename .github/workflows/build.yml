name: AUR Matrix Package Build and Publish

on:
  # Manual trigger enabled
  workflow_dispatch: {}
  
permissions:
  contents: write

env:
  # Variables for package management
  REPO_NAME: raveos-repo
  MAX_PKG_VERSIONS: 2
  
jobs:
  build_package:
    runs-on: ubuntu-latest
    
    strategy:
      fail-fast: false
      matrix:
        package_name: 
          - lib32-gtk2
          - gtk2
          - hydrapaper
          - kdoctools5
          - yaru-gtk-theme
          - gnome-clocks
          
    name: Build ${{ matrix.package_name }}

    container:
      image: archlinux:latest # Corrected image name
      options: --user root

    steps:
      - name: Install Build Dependencies
        run: |
          pacman -Sy --noconfirm
          pacman -S --noconfirm base-devel git
          
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Create Repository Directory
        run: mkdir -p ${{ env.REPO_NAME }}
        
      - name: Import GPG Key for Signing
        # CRITICAL FIX: Set GNUPGHOME to /root/.gnupg for consistency
        env:
          GNUPGHOME: /root/.gnupg 
        run: |
          echo "Setting up GNUPGHOME in $GNUPGHOME"
          mkdir -p $GNUPGHOME
          chmod 700 $GNUPGHOME
          
          # Import the private key
          echo "${{ secrets.GPG_PRIVATE_KEY }}" > private.key
          # Use --pinentry-mode loopback and the passphrase for non-interactive import
          gpg --batch --pinentry-mode loopback --import private.key
          
          # Set the imported key as ultimately trusted (required for automated signing)
          # Finds the imported key ID
          KEYID=$(gpg --batch --list-secret-keys --with-colons | grep -B 1 sec | grep -oP '(?<=^sec:)[^:]+')
          echo -e "trust\n5\ny\n" | gpg --batch --command-fd 0 --edit-key $KEYID
          
          rm private.key
          
      - name: Fetch and Build Package: ${{ matrix.package_name }}
        id: build
        env:
          PKG_NAME: ${{ matrix.package_name }}
          GNUPGHOME: /root/.gnupg # CRITICAL FIX: Ensure makepkg uses the imported key
        run: |
          echo "Building package: $PKG_NAME"
          
          # 1. Clone the AUR PKGBUILD
          git clone "https://aur.archlinux.org/$PKG_NAME.git"
          cd "$PKG_NAME"
          
          # 2. Build the package and install dependencies
          makepkg -s --skipchecksums --skippgpcheck --noconfirm
          
          # 3. Find the built package (.pkg.tar.zst)
          BUILT_PKG=$(find . -maxdepth 1 -name '*.pkg.tar.zst' | head -n 1)
          if [ -z "$BUILT_PKG" ]; then
            echo "::error::Package build failed or .pkg.tar.zst file not found."
            exit 1
          fi
          
          # 4. Sign the package using the key in $GNUPGHOME
          makepkg --sign
          
          echo "pkg_file=$BUILT_PKG" >> $GITHUB_OUTPUT
          echo "pkg_dir=$PKG_NAME" >> $GITHUB_OUTPUT

      - name: Publish and Clean Repository
        env:
          GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
          PKG_FILE: ${{ steps.build.outputs.pkg_file }}
          PKG_DIR: ${{ steps.build.outputs.pkg_dir }}
          GNUPGHOME: /root/.gnupg # CRITICAL FIX: Ensure repo-add uses the imported key
        run: |
          PKG_NAME=$(basename -s .pkg.tar.zst "$PKG_FILE" | sed -E 's/^(.*)-[0-9].*$/\1/')
          
          # 1. Move the new package and its signature
          mv "$PKG_DIR"/"$PKG_FILE" ${{ env.REPO_NAME }}/
          mv "$PKG_DIR"/"$PKG_FILE.sig" ${{ env.REPO_NAME }}/

          # 2. Update and sign the repository database
          # repo-add relies on gpg configuration in $GNUPGHOME
          repo-add -s -k "$GPG_KEY_ID" ${{ env.REPO_NAME }}/${{ env.REPO_NAME }}.db.tar.gz ${{ env.REPO_NAME }}/"$PKG_FILE"

          # 3. Clean up older package versions (Keep only $MAX_PKG_VERSIONS)
          cd ${{ env.REPO_NAME }}
          
          FILES_TO_DELETE=$(
            find . -maxdepth 1 -type f -name "${PKG_NAME}-*.pkg.tar.zst" \
            | sort -Vr \
            | tail -n +$((ENV.MAX_PKG_VERSIONS + 1))
          )
          
          if [ -n "$FILES_TO_DELETE" ]; then
            echo "Deleting old package versions:"
            echo "$FILES_TO_DELETE"
            
            for file in $FILES_TO_DELETE; do
              rm -f "$file"
              rm -f "$file.sig"
            done
            
            # Re-run repo-add to reflect the deletions
            repo-add -s -k "$GPG_KEY_ID" ${{ env.REPO_NAME }}.db.tar.gz *.pkg.tar.zst
          else
            echo "No old package versions to delete for $PKG_NAME. Keeping $MAX_PKG_VERSIONS."
          fi
          
      - name: Commit and Push Changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Build: Update ${{ matrix.package_name }} and repository database"
          branch: main
          file_pattern: '${{ env.REPO_NAME }}/**'
